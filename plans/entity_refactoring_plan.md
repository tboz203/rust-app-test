# Entity Refactoring Plan

## Current State Analysis

After reviewing the codebase, we've identified several redundancy and consistency issues that need to be addressed:

### Entity Implementation Redundancy

1. **Duplicate Entity Implementations:**
   - Manual implementations in singular-named files (`entity/category.rs`, `entity/product.rs`, `entity/product_category.rs`)
   - Generated implementations in plural-named files (`entity/categories.rs`, `entity/products.rs`, `entity/product_categories.rs`)

2. **Key Differences Between Implementations:**
   | Feature | Manual (singular) | Generated (plural) |
   |---------|-------------------|-------------------|
   | Origin | Manually written | Generated by sea-orm-codegen |
   | DateTime types | `DateTime<Utc>` | `DateTimeWithTimeZone` |
   | Decimal types | `BigDecimal` | `Decimal` |
   | Serialization | No derive macros | Derives `Serialize`, `Deserialize` |
   | Column attributes | Limited | More detailed (e.g., `column_type`) |
   | Relation definitions | Custom | Generated with cascade behaviors |
   | Additional fields | Some fields in manual versions | Strictly schema-based fields |

3. **Current Entity Module Structure:**
   - The main `entity.rs` module imports and re-exports the generated (plural) versions
   - However, code in repositories uses both versions inconsistently

### Repository and Model Issues

1. **Inconsistent Entity Usage:**
   - Repositories import both singular and plural entity versions
   - Type conversions are needed (e.g., between DateTime and Decimal types)

2. **Model Redundancy:**
   - API models in `models/` folder have overlap with entity models
   - Multiple conversion points create maintenance overhead

## Recommended Approach

### 1. Choose Generated Entity Implementations

We recommend standardizing on the **generated entity implementations** (plural-named files) for the following reasons:

- **Maintainability**: Generated entities stay in sync with database schema automatically
- **Completeness**: Include detailed column attributes and cascade behaviors
- **Serialization**: Already implement Serialize/Deserialize traits
- **Consistency**: Follow Sea-ORM's recommended patterns
- **Documentation**: Include generation metadata and comments

The manual implementations have some advantages (like custom datetime types), but these can be addressed through proper type conversion utilities rather than maintaining duplicate entity definitions.

### 2. Naming Convention

Standardize on the following naming conventions:

- **Module names**: Use plural form for entity modules (`categories.rs`, `products.rs`)
- **Entity types**: Use singular form for entity types (through re-exports in `entity.rs`)
- **Model types**: Use descriptive suffixes (`CategoryDto`, `ProductCreateRequest`)

### 3. Type Consistency

Rather than converting between types, we'll standardize on consistent types throughout the codebase:

- **BigDecimal**: Modify generated entities to use `BigDecimal` instead of `Decimal` for all monetary values
  - Configure Sea-ORM to use `BigDecimal` during code generation
  - Eliminate need for conversions between database and API models
  
- **DateTime Types**: Standardize on Sea-ORM's `DateTimeWithTimeZone` (which is a type alias for chrono's `DateTime<FixedOffset>`)
  - Replace usages of `DateTime<Utc>` with `DateTime<FixedOffset>` or `DateTimeWithTimeZone`
  - Ensure consistent timezone handling throughout the application

## Implementation Plan

### Phase 1: Entity Type Standardization

1. **Configure Sea-ORM Code Generation:**
   - Modify Sea-ORM code generation configuration to use BigDecimal instead of Decimal
   - Regenerate entity files with consistent types

2. **Update Entity Re-exports:**
   - Keep using the plural-named files for entity implementations
   - Maintain the singular-named type aliases in `entity.rs` for readability

3. **Update Model Types:**
   - Ensure all API models use DateTimeWithTimeZone and BigDecimal consistently

### Phase 2: Repository Updates

1. **Update Repository Imports:**
   - Standardize all repository imports to use only the re-exported entity types
   - Remove type conversion code since we're using consistent types throughout

2. **Simplify Repository Methods:**
   - Eliminate type conversion code between database and API models
   - Use the standardized types consistently

### Phase 3: Model Refinement

1. **Clear Separation of Concerns:**
   - Entities: Database schema representation only
   - DTOs: API request/response objects with validation
   - Internal models: Business logic models (if needed)

2. **Document Model Purpose:**
   - Add clear documentation comments to each model type

## Detailed Migration Path

This section provides a step-by-step guide for implementing the refactoring with minimal disruption to ongoing development.

### Step 1: Configure Sea-ORM Code Generation

Update the Sea-ORM code generation configuration to use BigDecimal for decimal fields:

1. Create or update the Sea-ORM codegen configuration file:

```toml
# sea-orm-cli.toml
[codegen]
decimal_type = "bigdecimal::BigDecimal"
datetime_type = "sea_orm::prelude::DateTimeWithTimeZone"
```

2. Regenerate entity files:

```bash
sea-orm-cli generate entity -o src/entity
```

3. Verify that the generated entities use BigDecimal for price fields and DateTimeWithTimeZone for datetime fields:

```rust
// Example of generated entity with BigDecimal
#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "products")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub name: String,
    #[sea_orm(column_type = "Text", nullable)]
    pub description: Option<String>,
    #[sea_orm(column_type = "Decimal(Some((10, 2)))")]
    pub price: BigDecimal,  // Now using BigDecimal directly
    pub sku: Option<String>,
    pub created_at: DateTimeWithTimeZone,
    pub updated_at: DateTimeWithTimeZone,
}
```

### Step 2: Update Entity Module

Update `src/entity.rs` to standardize on the generated implementations:

```rust
pub mod products;
pub mod categories;
pub mod product_categories;

// Re-export with singular names for readability and domain semantics
pub use categories::Entity as Category;
pub use categories::Model as CategoryModel;
pub use categories::ActiveModel as CategoryActiveModel;
pub use categories::Column as CategoryColumn;

pub use products::Entity as Product;
pub use products::Model as ProductModel;
pub use products::ActiveModel as ProductActiveModel;
pub use products::Column as ProductColumn;

pub use product_categories::Entity as ProductCategory;
pub use product_categories::Model as ProductCategoryModel;
pub use product_categories::ActiveModel as ProductCategoryActiveModel;
pub use product_categories::Column as ProductCategoryColumn;
```

### Step 3: Update Repository Layer

Example of updating the `CategoryRepository` imports:

```rust
// Before
use crate::entity::{categories, product_categories, products};
use crate::entity::{Category, Product, ProductCategory};

// After
use crate::entity::{Category, CategoryModel, CategoryActiveModel, CategoryColumn};
use crate::entity::{ProductCategory, ProductCategoryModel, ProductCategoryColumn};
use crate::entity::{Product, ProductModel};
```

Example of updating a repository method (before):

```rust
pub async fn get_product(&self, id: i32) -> Result<ProductResponse, ApiError> {
    // Find product by ID
    let product = Product::find_by_id(id)
        .one(&self.conn)
        .await
        .map_err(ApiError::SeaOrmDatabase)?
        .ok_or_else(|| ApiError::not_found_simple("Product not found"))?;
        
    // Fetch categories
    let categories = Self::get_product_categories(id, &self.conn)
        .await
        .map_err(ApiError::SeaOrmDatabase)?;
        
    // Convert price from Sea-ORM Decimal to BigDecimal for the response
    let price_str = product.price.to_string();
    let price = BigDecimal::from_str(&price_str)
        .map_err(|_| ApiError::internal_server_error("Invalid price format"))?;
        
    // Convert timezone-aware datetime to Utc
    let created_at = chrono::DateTime::<chrono::Utc>::from_utc(
        product.created_at.naive_utc(),
        chrono::Utc,
    );
    let updated_at = chrono::DateTime::<chrono::Utc>::from_utc(
        product.updated_at.naive_utc(),
        chrono::Utc,
    );
    
    Ok(ProductResponse {
        id: product.id,
        name: product.name,
        description: product.description,
        price,
        sku: product.sku,
        categories,
        created_at,
        updated_at,
    })
}
```

Example of updating a repository method (after):

```rust
pub async fn get_product(&self, id: i32) -> Result<ProductResponse, ApiError> {
    // Find product by ID
    let product = Product::find_by_id(id)
        .one(&self.conn)
        .await
        .map_err(ApiError::SeaOrmDatabase)?
        .ok_or_else(|| ApiError::not_found_simple("Product not found"))?;
        
    // Fetch categories
    let categories = Self::get_product_categories(id, &self.conn)
        .await
        .map_err(ApiError::SeaOrmDatabase)?;
    
    // No type conversions needed since entity and API models use the same types
    Ok(ProductResponse {
        id: product.id,
        name: product.name,
        description: product.description,
        price: product.price, // BigDecimal is used consistently
        sku: product.sku,
        categories,
        created_at: product.created_at, // DateTimeWithTimeZone is used consistently
        updated_at: product.updated_at,
    })
}
```

### Step 4: Example of Creating a Product (Before and After)

Before:

```rust
// Create category active model
let category = categories::ActiveModel {
    name: Set(req.name.clone()),
    description: Set(req.description.clone()),
    ..Default::default()
};

// Insert category
let category_model = category
    .insert(txn)
    .await
    .map_err(ApiError::SeaOrmDatabase)?;
```

After:

```rust
// Create category active model
let category = CategoryActiveModel {
    name: Set(req.name.clone()),
    description: Set(req.description.clone()),
    ..Default::default()
};

// Insert category
let category_model = category
    .insert(txn)
    .await
    .map_err(ApiError::SeaOrmDatabase)?;
```

### Step 5: Update API Model Definitions

Update the API model types to use the same types as the entities:

Before:
```rust
#[derive(Debug, Serialize, FromRow)]
pub struct Category {
    pub id: i32,
    pub name: String,
    pub description: Option<String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}
```

After:
```rust
#[derive(Debug, Serialize, FromRow)]
pub struct Category {
    pub id: i32,
    pub name: String,
    pub description: Option<String>,
    pub created_at: DateTimeWithTimeZone,
    pub updated_at: DateTimeWithTimeZone,
}
```

### Step 6: Implementation Timeline

To minimize disruption, implement the changes in this order:

1. **Preparation (1-2 days)**
   - Configure Sea-ORM code generation to use BigDecimal
   - Regenerate entity files
   - Update entity.rs with comprehensive re-exports
   
2. **Repository Updates (2-3 days)**
   - Update imports in repository files
   - Simplify repository methods by removing type conversions
   - Test each repository function after changes
   
3. **API Model Updates (1-2 days)**
   - Update API model types to use DateTimeWithTimeZone and BigDecimal
   - Ensure response serialization works correctly
   
4. **Entity Cleanup (1 day)**
   - Remove redundant entity files after all repositories are updated
   - Validate that imports resolve correctly
   
5. **API and Integration Testing (2-3 days)**
   - Run comprehensive test suite
   - Test API endpoints with various inputs
   - Fix any issues found during testing

### Step 7: Code Quality Checks

Before finalizing:

1. Run `cargo clippy` to catch any remaining issues
2. Ensure consistent code formatting with `cargo fmt`
3. Update documentation comments
4. Verify type consistency throughout the codebase

## Repository Interface Updates

### Current Pattern Issues

1. Inconsistent imports create confusion:
   ```rust
   use crate::entity::{categories, product_categories, products};  // Module imports
   use crate::entity::{Category, Product, ProductCategory};        // Entity imports
   ```

2. Type inconsistencies requiring conversions:
   ```rust
   // DateTime conversion
   let created_at = chrono::DateTime::<chrono::Utc>::from_utc(
       product_model.created_at.naive_utc(),
       chrono::Utc,
   );
   
   // Decimal conversion
   let price_str = product.price.to_string();
   let price = BigDecimal::from_str(&price_str)
       .map_err(|_| ApiError::internal_server_error("Invalid price format"))?;
   ```

### New Pattern

1. Consistent imports using re-exports:
   ```rust
   use crate::entity::{
       Category, CategoryModel, CategoryActiveModel, CategoryColumn,
       Product, ProductModel, ProductActiveModel, ProductColumn,
       ProductCategory, ProductCategoryModel, ProductCategoryColumn
   };
   ```

2. Consistent types throughout:
   ```rust
   // No type conversions needed
   Ok(ProductResponse {
       id: product.id,
       name: product.name,
       description: product.description,
       price: product.price, // BigDecimal used throughout
       sku: product.sku,
       categories,
       created_at: product.created_at, // DateTimeWithTimeZone used throughout
       updated_at: product.updated_at,
   })
   ```

## API Model Structure

While not directly part of the entity refactoring, we recommend these practices for API models:

1. Clear naming conventions:
   - `*Request` - For incoming API requests
   - `*Response` - For outgoing API responses
   - `*Dto` - For data transfer objects

2. Type consistency across layers:
   - Use DateTimeWithTimeZone for all date/time fields
   - Use BigDecimal for all monetary values
   - Ensure serialization/deserialization works correctly with these types

3. Validation should remain in API models, not entities:
   ```rust
   #[derive(Debug, Deserialize, Validate)]
   pub struct CreateProductRequest {
       #[validate(length(min = 1, max = 255))]
       pub name: String,
       #[validate(custom = "validate_decimal_positive")]
       pub price: BigDecimal,  // Uses same type as entity
       // ...
   }
   ```

## Risk Mitigation

- **Incremental Testing**: Test each repository function after updates
- **Database Validation**: Verify all database operations work correctly
- **API Tests**: Ensure API responses maintain the same structure
- **Serialization Testing**: Verify BigDecimal and DateTimeWithTimeZone serialize/deserialize correctly
- **Code Reviews**: Have team members review changes before merging
- **Feature Flags**: Consider implementing behind feature flags if needed
- **Rollback Plan**: Be prepared to revert to previous implementation if issues arise

## Future Considerations

- Configure Sea-ORM code generation to support custom type mappings
- Create a code generation configuration file to standardize the process
- Consider adding custom derive macros to simplify entity-to-DTO mapping
- Explore introducing a formal DTO layer for cleaner separation of concerns
- Consider implementing database migration scripts to ensure schema compatibility
- Add more comprehensive API documentation for entity and model types